<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Learn Docker, from the beginning, part IV</title>
    <meta name="description" content="[object Object]">
    
    
    <link rel="preload" href="/assets/css/0.styles.b244743b.css" as="style"><link rel="preload" href="/assets/js/app.31c2901f.js" as="script"><link rel="preload" href="/assets/js/7.1b275639.js" as="script"><link rel="preload" href="/assets/js/6.6ae5d1ce.js" as="script"><link rel="preload" href="/assets/js/22.e9533634.js" as="script"><link rel="prefetch" href="/assets/js/1.1b576644.js"><link rel="prefetch" href="/assets/js/10.7bac90a4.js"><link rel="prefetch" href="/assets/js/11.01a6b72e.js"><link rel="prefetch" href="/assets/js/12.8977a44a.js"><link rel="prefetch" href="/assets/js/13.ce52cddb.js"><link rel="prefetch" href="/assets/js/14.0e8b16fb.js"><link rel="prefetch" href="/assets/js/15.13760c26.js"><link rel="prefetch" href="/assets/js/16.a9d77c7d.js"><link rel="prefetch" href="/assets/js/17.328b9ea3.js"><link rel="prefetch" href="/assets/js/18.30f6b9d8.js"><link rel="prefetch" href="/assets/js/19.0a6d2469.js"><link rel="prefetch" href="/assets/js/20.20c70880.js"><link rel="prefetch" href="/assets/js/21.527892f2.js"><link rel="prefetch" href="/assets/js/23.778c48e1.js"><link rel="prefetch" href="/assets/js/24.899da95f.js"><link rel="prefetch" href="/assets/js/25.7fec6931.js"><link rel="prefetch" href="/assets/js/26.6a98482d.js"><link rel="prefetch" href="/assets/js/27.b5bb63d4.js"><link rel="prefetch" href="/assets/js/28.bd781958.js"><link rel="prefetch" href="/assets/js/29.6aec636a.js"><link rel="prefetch" href="/assets/js/3.262e56e6.js"><link rel="prefetch" href="/assets/js/30.2c751f2e.js"><link rel="prefetch" href="/assets/js/31.51bb42b6.js"><link rel="prefetch" href="/assets/js/32.6eba583a.js"><link rel="prefetch" href="/assets/js/33.7bbe7966.js"><link rel="prefetch" href="/assets/js/34.5d0aec38.js"><link rel="prefetch" href="/assets/js/35.e5a74aab.js"><link rel="prefetch" href="/assets/js/36.589ace7f.js"><link rel="prefetch" href="/assets/js/37.0193942c.js"><link rel="prefetch" href="/assets/js/38.d83d90fc.js"><link rel="prefetch" href="/assets/js/39.a85380b9.js"><link rel="prefetch" href="/assets/js/4.56ae630c.js"><link rel="prefetch" href="/assets/js/40.39b1e103.js"><link rel="prefetch" href="/assets/js/41.0b22e324.js"><link rel="prefetch" href="/assets/js/42.556fa283.js"><link rel="prefetch" href="/assets/js/43.e82076c1.js"><link rel="prefetch" href="/assets/js/44.1cd21cb2.js"><link rel="prefetch" href="/assets/js/45.3f79dff7.js"><link rel="prefetch" href="/assets/js/46.0a179e94.js"><link rel="prefetch" href="/assets/js/47.e97ae5b7.js"><link rel="prefetch" href="/assets/js/48.822c2a98.js"><link rel="prefetch" href="/assets/js/49.8b1b0d47.js"><link rel="prefetch" href="/assets/js/5.373600b1.js"><link rel="prefetch" href="/assets/js/50.b97d2b58.js"><link rel="prefetch" href="/assets/js/51.b9d2d49d.js"><link rel="prefetch" href="/assets/js/52.19c8dd08.js"><link rel="prefetch" href="/assets/js/53.1bc9c048.js"><link rel="prefetch" href="/assets/js/54.d24a1bb1.js"><link rel="prefetch" href="/assets/js/55.5976b034.js"><link rel="prefetch" href="/assets/js/56.01b047b4.js"><link rel="prefetch" href="/assets/js/57.3d8e645d.js"><link rel="prefetch" href="/assets/js/58.4c3618ed.js"><link rel="prefetch" href="/assets/js/59.c9fcb63f.js"><link rel="prefetch" href="/assets/js/60.0d0d60b5.js"><link rel="prefetch" href="/assets/js/61.6e98b987.js"><link rel="prefetch" href="/assets/js/62.f471b55a.js"><link rel="prefetch" href="/assets/js/63.7953f0c8.js"><link rel="prefetch" href="/assets/js/64.65da64a1.js"><link rel="prefetch" href="/assets/js/65.830799e0.js"><link rel="prefetch" href="/assets/js/66.2f98a845.js"><link rel="prefetch" href="/assets/js/67.e4a602b1.js"><link rel="prefetch" href="/assets/js/68.dd154640.js"><link rel="prefetch" href="/assets/js/69.8f6a0c8b.js"><link rel="prefetch" href="/assets/js/8.a354cea0.js"><link rel="prefetch" href="/assets/js/9.be23d1a2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b244743b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/about/" class="nav-link">About</a></div><div class="nav-item"><a href="/author/" class="nav-link">Author</a></div><div class="nav-item"><a href="/articles/" class="nav-link">Blog</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/about/" class="nav-link">About</a></div><div class="nav-item"><a href="/author/" class="nav-link">Author</a></div><div class="nav-item"><a href="/articles/" class="nav-link">Blog</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Learn Docker, from the beginning, part IV</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/docker-four.html#resources" class="sidebar-link">Resources</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="learn-docker-from-the-beginning-part-iv"><a href="#learn-docker-from-the-beginning-part-iv" aria-hidden="true" class="header-anchor">#</a> Learn Docker, from the beginning, part IV</h1> <p><img src="https://thepracticaldev.s3.amazonaws.com/i/1trd1enpr5ocm0vt3xhg.jpeg" alt="alt text" title="Docker part IV"></p> <p>Follow me on <a href="https://twitter.com/chris_noring" target="_blank" rel="noopener noreferrer">Twitter<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, happy to take your suggestions on topics or improvements /Chris</p> <p>This article is part of a series:</p> <ul><li><a href="https://dev.to/softchris/docker---from-the-beginning-part-i-28c6https://dev.to/softchris/docker---from-the-beginning-part-i-28c6" target="_blank" rel="noopener noreferrer">Docker — from the beginning part I<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, this covers why Docker, the basic concepts and the commands we need to manage things like images and containers.</li> <li><a href="https://dev.to/softchris/docker-from-the-beginning---part-ii-5g8n" target="_blank" rel="noopener noreferrer">Docker — from the beginning, Part II<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, this is about Volumes and how we can use volumes to persist data but also how we can turn our development environment into a Volume and make our development experience considerably better</li> <li><a href="https://softchris.github.io/pages/docker-three.html" target="_blank" rel="noopener noreferrer">Docker — from the beginning, Part III<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>,
this is about how to deal with Databases, putting them into containers and how to make containers talk to other containers using legacy linking but also the new standard through networks</li> <li>Docker — from the beginning, Part IV, <strong>we are here</strong></li> <li><a href="https://softchris.github.io/pages/docker-five.html" target="_blank" rel="noopener noreferrer">Docker - from the beginning, Part V<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, this part is the second and concluding part on Docker Compose where we cover Volumes, Environment Variables and working with Databases and Networks</li></ul> <blockquote><p>This part is about dealing with more than two Docker containers. You will come to a point eventually when you have so many containers to manage it feels unmanageable. You can only keep typing docker run to a certain point, as soon as you start spinning up multiple containers it just hurts your head and your fingers. To solve this we have Docker Compose.</p></blockquote> <p>TLDR; Docker Compose is a huge topic, for that reason this article is split into two parts. In this part, we will describe why Docker Compose and show when it shines. In the second part on Docker Compose we will cover more advanced topics like Environment Variables, Volumes and Databases.</p> <p>In this part we will cover:</p> <ul><li><strong>Why docker compose</strong>, it's important to understand, at least on a high level that there are two major architectures Monolith and Microservices and that Docker Compose really helps with managing the latter</li> <li><strong>Features</strong>, we will explain what feature Docker Compose supports so we will come to understand why it's such a good fit for our chosen Microservice architecture</li> <li><strong>When Docker isn't enough</strong>, we will explain at which point using Docker commands becomes tedious and painful and when using Docker Compose is starting to look more and more enticing</li> <li><strong>In action</strong>, lastly we will build a docker-compose.yaml file from scratch and learn how to manage our containers using Docker Compose and some core commands</li></ul> <h2 id="resources"><a href="#resources" aria-hidden="true" class="header-anchor">#</a> Resources</h2> <p>Using Docker and containerization is about breaking apart a monolith into microservices. Throughout this series, we will learn to master Docker and all its commands. Sooner or later you will want to take your containers to a production environment. That environment is usually the Cloud. When you feel you've got enough Docker experience have a look at these links to see how Docker can be used in the Cloud as well:</p> <ul><li><a href="https://docs.microsoft.com/en-gb/azure/containers/?wt.mc_id=personal-blog-chnoring" target="_blank" rel="noopener noreferrer">Containers in the Cloud<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
Great overview page that shows what else there is to know about containers in the Cloud</li> <li><a href="https://docs.microsoft.com/en-gb/azure/container-instances/container-instances-tutorial-prepare-app?wt.mc_id=personal-blog-chnoring" target="_blank" rel="noopener noreferrer">Deploying your containers in the Cloud<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> Tutorial that shows how easy it is to leverage your existing Docker skill and get your services running in the Cloud</li> <li><a href="https://docs.microsoft.com/en-gb/azure/container-instances/container-instances-tutorial-prepare-acr?wt.mc_id=personal-blog-chnoring" target="_blank" rel="noopener noreferrer">Creating a container registry<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
Your Docker images can be in Docker Hub but also in a Container Registry in the Cloud. Wouldn't it be great to store your images somewhere and actually be able to create a service from that Registry in a matter of minutes?</li></ul> <p>##Why Docker Compose
Docker Compose is meant to be used when we need to manage many services independently. What we are describing is something called a microservice architecture.</p> <p>###Microservice architecture
Let's define some properties on such an architecture:</p> <ul><li><strong>Loosely coupled</strong>, this means they are not dependent on another service to function, all the data they need is just there. They can interact with other services though but that's by calling their external API with for example an HTTP call</li> <li><strong>Independently deployable</strong>, this means we can start, stop and rebuild them without affecting other services directly.</li> <li><strong>Highly maintainable and testable</strong>, services are small and thus there is less to understand and because there are no dependencies testing becomes simpler</li> <li><strong>Organized around business capabilities</strong>, this means we should try to find different themes like booking, products management, billing and so on</li></ul> <p>We should maybe have started with the question of why we want this architecture? It's clear from the properties listed above that it offers a lot of flexibility, it has less to no dependencies and so on. That sounds like all good things, so is that the new architecture that all apps should have?</p> <p>As always it depends. There are some criteria where Microservices will shine as opposed to a Monolithic architecture such as:</p> <ul><li><strong>Different tech stacks/emerging techs</strong>, we have many development teams and they all want to use their own tech stack or want to try out a new tech without having to change the entire app. Let each team build their own service in their chosen tech as part of a Microservice architecture.</li> <li><strong>Reuse</strong>, you really want to build a certain capability once, like for example billing, if that's being broken out in a separate service it makes it easier to reuse for other applications. Oh and in a microservices architecture you could easily combine different services and create many apps from it</li> <li><strong>Minimal failure impact</strong>, when there is a failure in a monolithic architecture it might bring down the entire app, with microservices you might be able to shield yourself better from failure</li></ul> <p>There are a ton more arguments on why Micro services over Monolithic architecture. The interested reader is urged to have a look at the following <a href="https://www.cio.com/article/3201193/it-strategy/7-reasons-to-switch-to-microservices-and-5-reasons-you-might-not-succeed.html" target="_blank" rel="noopener noreferrer">link<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> .</p> <p>###The case for Docker Compose
The description of a Microservice architecture tells us that we need a bunch of services organized around business capabilities. Furthermore, they need to be independently deployable and we need to be able to use different tech stacks and many more things. In my opinion, this sounds like Docker would be a great fit generally. The reason we are making a case for Docker Compose over Docker is simply the sheer size of it. If we have more than two containers the amount of commands we need to type suddenly grows in a linear way. Let's explain in the next section what features Docker Compose have that makes it scale so well when the number of services increase.</p> <p>##Docker Compose features overview
Now Docker Compose enables us to scale really well in the sense that we can easily build several images at once, start several containers and many more things. A complete listing of features is as follows:</p> <ul><li><strong>Manages</strong> the whole application life cycle.</li> <li><strong>Start</strong>, stop and rebuild services</li> <li><strong>View</strong> the status of running services</li> <li><strong>Stream</strong> the log output of running services</li> <li><strong>Run</strong> a one-off command on a service</li></ul> <p>As we can see it takes care of everything we could possibly need when we need to manage a microservice architecture consisting of many services.</p> <p>##When plain Docker isn't enough anymore
Let's recap on how Docker operates and what commands we need and let's see where that takes us when we add a service or two.</p> <p>To dockerize something, we know that we need to:</p> <ul><li><strong>define a Dockerfile</strong> that contains what OS image we need, what libraries we need to install, env variables we need to set, ports that need opening and lastly how to - start up our service</li> <li><strong>build an image</strong> or pull down an existing image from Docker Hub</li> <li><strong>create</strong> and run a container</li></ul> <p>Now, using Docker Compose we still need to do the part with the Dockerfile but Docker Compose will take care of building the images and managing the containers. Let's illustrate what the commands might look like with plain Docker:</p> <blockquote><p>docker build -t some-image-name .</p></blockquote> <p>Followed by</p> <blockquote><p>docker run -d -p 8000:3000 --name some-container-name some-image-name</p></blockquote> <p>Now that's not a terrible amount to write, but imagine you have three different services you need to do this for, then it suddenly becomes six commands and then you have the tear down which is two more commands and, that doesn't really scale.</p> <p><img src="https://thepracticaldev.s3.amazonaws.com/i/9zdbajjweos0erfkjl2h.gif" alt="alt text" title="Docker not scaling"></p> <p>###Enter docker-compose.yaml
This is where Docker Compose really shines. Instead of typing two commands for every service you want to build you can define all services in your project in one file, a file we call <code>docker-compose.yaml</code>. You can configure the following topics inside of a <code>docker-compose.yaml</code> file:</p> <ul><li><strong>Build</strong>, we can specify the building context and the name of the Dockerfile, should it not be called the standard name</li> <li><strong>Environment</strong>, we can define and give value to as many environment variables as we need</li> <li><strong>Image</strong>, instead of building images from scratch we can define ready-made images that we want to pull down from Docker Hub and use in our solution</li> <li><strong>Networks</strong>, we can create networks and we can also for each service specify which network it should belong to, if any</li> <li><strong>Ports</strong>, we can also define the port forwarding, that is which external port should match what internal port in the container</li> <li><strong>Volumes</strong>, of course, we can also define volumes</li></ul> <p>##Docker compose in action
Ok so at this point we understand that Docker Compose can take care of pretty much anything we can do on the command line and that it also relies on a file <code>docker-compose.yaml</code> to know what actions to carry out.</p> <p>###Authoring a docker-compose.yml file
Let's actually try to create such a file and let's give it some instructions. First, though let's do a quick review of a typical projects file structure. Below we have a project consisting of two services, each having their own directory. Each directory has a <code>Dockerfile</code> that contains instructions on how to build a service.</p> <p>It can look something like this:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker-compose.yaml
/product-service
  app.js
  package.json
  Dockerfile
/inventory-service
  app.js
  package.json
  Dockerfile
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Worth noting above is how we create the <code>docker-compose.yaml</code> file at the root of our project. The reason for doing so is that all the services we aim to build and how to build and start them should be defined in one file, our <code>docker-compose.yml</code>.
Ok, let's open <code>docker-compose.yaml</code> and enter our first line:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// docker-compose.yaml
version: '3'
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Now, it actually matters what you specify here. Currently, Docker supports three different major versions. 3 is the latest major version, read more here how the different versions differ, cause they do support different functionality and the syntax might even differ between them Docker versions <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener noreferrer">offical docs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
Next up let's define our services:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// docker-compose.yaml
version: '3'
services:
  product-service:
    build:
      context: ./product-service
    ports:
      - &quot;8000:3000&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Ok, that was a lot at once, let's break it down:</p> <ul><li><strong>services:</strong>, there should only be one of this in the whole docker-compose.yaml file. Also, note how we end with <code>:</code>, we need that or it won't be valid syntax, that is generally true for any command</li> <li><strong>product-service</strong>, this is a name we choose ourselves for our service</li> <li><strong>build:</strong>, this is instructing Docker Compose how to build the image. If we have a ready-made image already we don't need to specify this one</li> <li><strong>context:</strong>, this is needed to tell Docker Compose where our <code>Dockerfile</code> is, in this case, we say that it needs to go down a level to the <code>product-service</code> directory</li> <li><strong>ports:</strong>, this is the port forwarding in which we first specify the external port followed by the internal port</li></ul> <p>All this corresponds to the following two commands:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker build -t [default name]/product-service .
docker run -p 8000:3000 --name [default name]/product-service
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Well, it's almost true, we haven't exactly told Docker Compose yet to carry out the building of the image or to create and run a container. Let's learn how to do that starting with how to build an image:</p> <blockquote><p>docker-compose build</p></blockquote> <p>The above will build every single service you have specified in <code>docker-compose.yaml</code>. Let's look at the output of our command:</p> <p><img src="https://thepracticaldev.s3.amazonaws.com/i/gezojc19cb7cvlda0fcr.png" alt="alt text" title="Docker output"></p> <p>Above we can see that our image is being built and we also see it is given the full name <code>compose-experiments_product-service:latest</code>, as indicated by the last row. The name is derived from the directory we are in, that is <code>compose-experiments</code> and the other part is the name we give the service in the <code>docker-compose.yaml</code> file.
Ok as for spinning it up we type:</p> <blockquote><p>docker-compose up</p></blockquote> <p>This will again read our <code>docker-compose.yaml</code> file but this time it will create and run a container. Let's also make sure we run our container in the background so we add the flag <code>-d</code>, so full command is now:</p> <blockquote><p>docker-compose up -d</p></blockquote> <p>Ok, above we can see that our service is being created. Let's run <code>docker ps</code> to verify the status of our newly created container:
It seems to be up and running on port <code>8000</code>. Let's verify:
Ok, so went to the terminal and we can see we got a container. We know we can bring it down with either docker stop or docker kill but let's do it the docker-compose way:</p> <blockquote><p>docker-compose down</p></blockquote> <p>As we can see above the logs is saying that it is stopping and removing the container, it seems to be doing both <code>docker stop [id]</code> and <code>docker rm [id]</code> for us, sweet 😃
It should be said if all we want to do is stop the containers we can do so with:</p> <blockquote><p>docker-compose stop</p></blockquote> <p>I don't know about you but at this point, I'm ready to stop using <code>docker build</code>, <code>docker run</code>, <code>docker stop</code> and <code>docker rm</code>. Docker compose seems to take care of the full life cycle 😃</p> <p>##Docker compose showing off
Let's do a small recap so far. Docker compose takes care of the full life cycle of managing services for us. Let's try to list the most used Docker commands and what the corresponding command in Docker Compose would look like:</p> <ul><li><code>docker build</code> becomes <code>docker-compose build</code>, the Docker Compose version is able to build all the services specified in <code>docker-compose.yaml</code> but we can also specify it to build a single service, so we can have more granular control if we want to</li> <li><code>docker build + docker run</code> becomes <code>docker-compose up</code>, this does a lot of things at once, if your images aren't built previously it will build them and it will also create containers from the images</li> <li><code>docker stop</code> becomes <code>docker-compose stop</code>, this is again a command that in Docker Compose can be used to stop all the containers or a specific one if we give it a single container as an argument</li> <li><code>docker stop &amp;&amp; docker rm</code> becomes <code>docker-compose down</code>, this will bring down the containers by first stopping them and then removing them so we can start fresh</li></ul> <p>The above in itself is pretty great but what's even greater is how easy it is to keep on expanding our solution and add more and more services to it.</p> <p>##Building out our solution
Let's add another service, just to see how easy it is and how well it scales. We need to do the following:</p> <ul><li><strong>add</strong> a new service entry in our <code>docker-compose.yaml</code></li> <li><strong>build</strong> our image/s <code>docker-compose build</code></li> <li><strong>run</strong> <code>docker-compose up</code></li></ul> <p>Let's have a look at our <code>docker-compose.yaml</code> file and let's add the necessary info for our next service:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// docker-compose.yaml

version: '3'
services:
  product-service:
    build:
      context: ./product-service
    ports:
      - &quot;8000:3000&quot;
  inventory-service:
    build:
      context: ./inventory-service
    ports:
        - &quot;8001:3000&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>Ok then, let's get these containers up and running, including our new service:</p> <blockquote><p>docker-compose up</p></blockquote> <p>Wait, aren't you supposed to run <code>docker-compose build</code> ? Well, actually we don't need to <code>docker-compose up</code> does it all for us, building images, creating and running containers.</p> <p><img src="https://thepracticaldev.s3.amazonaws.com/i/09jstlay2u68e0uhhllw.gif" alt="alt text" title="Docker awesome"></p> <p>CAVEAT, it's not so simple, that works fine for a first-time build + run, where no images exist previously. If you are doing a change to a service, however, that needs to be rebuilt, that would mean you need to run docker-compose build first and then you need to run docker-compose up.</p> <p>##Summary
Here is where we need to put a stop to the first half of covering Docker Compose, otherwise it would just be too much. We have been able to cover the motivation behind Docker Compose and we got a lightweight explanation to Microservice architecture. Furthermore, we talked about Docker versus Docker Compose and finally, we were able to contrast and compare the Docker Compose command to plain Docker commands.
Thereby we hopefully were able to show how much easier it is to use Docker Compose and specify all your services in a <code>docker-compose.yaml</code> file.
We did say that there was much more to Docker Compose like Environment variables, Networks, and Databases but that will come in the next part.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.31c2901f.js" defer></script><script src="/assets/js/7.1b275639.js" defer></script><script src="/assets/js/6.6ae5d1ce.js" defer></script><script src="/assets/js/22.e9533634.js" defer></script>
  </body>
</html>
